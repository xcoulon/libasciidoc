{
package parser 

import (
    "io"
    "fmt"
    "strconv"
    "strings"
    "unicode"
    "github.com/bytesparadise/libasciidoc/pkg/types"

    log "github.com/sirupsen/logrus"
    "github.com/davecgh/go-spew/spew"
)

}

// ------------------------------------------
// Document Raw Line (main rule)
// Identify the delimiters for raw blocks
// ------------------------------------------
DefaultDocumentFragmentElement <- 
    BlankLine
    / Section
    / ImageBlock
    / BlockAttributes
    / FileInclusion 
    / BlockDelimiter 
    / ThematicBreak // must appear before ListElement :/
    / ListElement
    / ListElementContinuation
    / SingleLineComment
    / AttributeDeclaration
    / AttributeReset
    / Admonition
    // if no match, parser will return an error and content will be store in a RawLine

// when parsing rawlines within a delimited block, there are fewer types of fragment element to expect.
DocumentFragmentElementWithinParagraph <- 
    BlankLine
    / SingleLineComment
    // if no match, parser will return an error and content will be store in a RawLine

// when parsing rawlines within a verbatim delimited block, there are fewer types of fragment element to expect.
DocumentFragmentElementWithinVerbatimBlock <- 
    delimiter:(BlockDelimiter)
    &{
        // only accept if the delimiter matches the current delimited block
        return c.isValidBlockDelimiter(delimiter.(*types.BlockDelimiter))
    }{
        return delimiter, nil
    }
    // if no match, parser will return an error and content will be store in a RawLine

// when parsing rawlines within a normal delimited block, there are slightly fewer types of fragment element to expect.
DocumentFragmentElementWithinNormalBlock <- 
    (delimiter:BlockDelimiter
    &{
        // only accept if the delimiter matches the current delimited block
        return c.isValidBlockDelimiter(delimiter.(*types.BlockDelimiter))
    }{
        return delimiter, nil
    })
    / BlankLine
    / ImageBlock
    / BlockAttributes
    / FileInclusion 
    / ThematicBreak // must appear before ListElement :/
    / ListElement
    / ListElementContinuation
    / SingleLineComment
    / Admonition
    // if no match, parser will return an error and content will be store in a RawLine

// ------------------------------------------
// Admonitions
// ------------------------------------------
AdmonitionKind <- "TIP" {
    return types.Tip, nil
} / "NOTE" {
    return types.Note, nil
} / "IMPORTANT" {
    return types.Important, nil
} / "WARNING" {
    return types.Warning, nil
} / "CAUTION" {
    return types.Caution, nil
}

Admonition <-  kind:(AdmonitionKind) ": " content:([^\r\n]* {
        return string(c.text), nil
    }) { 
        return types.NewAdmonitionLine(kind.(string), content.(string))
    }

// ------------------------------------------
// Attribute Declarations and Resets
// ------------------------------------------
AttributeDeclaration <- 
    #{
        // for attribute declarations, we always enable the 'header' substitutions
        return c.setCurrentSubstitution("header")
    }
    ":" name:(AttributeName) ":" 
    value:(AttributeDeclarationValue)? 
    EOL {
        d := types.NewAttributeDeclaration(name.(string), types.Reduce(value, strings.TrimSpace))
        // c.globalStore.AddAttributeDeclaration(d)
        return d, nil
    } 

// AttributeName must be at least one character long, 
// must begin with a word character (A-Z, a-z, 0-9 or _) and 
// must only contain word Word and hyphens ("-").
AttributeName <- [\pL0-9_] ([\pL0-9-])* {
        return string(c.text), nil
    }

AttributeDeclarationValue <- Space+ elements:(AttributeDeclarationValueElement)* {
        return types.Reduce(elements.([]interface{}), strings.TrimSpace), nil
    }

AttributeDeclarationValueElement <- !EOL 
    element:(
        ([^\r\n{]+ {
                return types.NewStringElement(string(c.text))
        })
        / AttributeSubstitution
        / ("{" { // standalone '{'
            return types.NewStringElement(string(c.text))
        })
    ) { 
        return element, nil
    }

AttributeReset <- ":!" name:(AttributeName) ":" Space* EOF {
    return types.NewAttributeReset(name.(string))
} / ":" name:(AttributeName) "!:" Space* EOF {
    return types.NewAttributeReset(name.(string))
}

// ------------------------------------------
// Block and Inline Attributes
// ------------------------------------------
BlockAttributes <- 
    #{
        // for block attributes, we always enable the 'header' substitutions
        return c.setCurrentSubstitution("header")
    }
    attributes:(
        // shorthand syntax for anchors. Eg: `[[an_id]]`
        (anchor:(ShortHandAnchor) Space* {
            return anchor, nil
        })
        // shorthand syntax for titles. Eg: `.a title`
        / (title:(ShortHandTitle) Space* {
            return title, nil
        })
        // default syntax
        / (attributes:(LongHandAttributes) Space* {
            return attributes, nil
        })
    )+ {
        c.unsetCurrentSubstitution()
        return types.NewAttributes(attributes.([]interface{})...)
    }  

InlineAttributes <-
    "["
    attributes:(
        (
            !"]" // quick escape
            attribute:(PositionalAttribute / NamedAttribute)
        ) {
            return attribute, nil
        }
    )*
    "]" {
        return types.NewAttributes(attributes.([]interface{})...)
    }

// shorthand syntax for anchors. Eg: `[[An ID]]`
ShortHandAnchor <-
   "[[" 
    id:(
        elements:(
            ([^=\r\n\uFFFD{\]]+ { // spaces, commas and dots are allowed in this syntax
                return types.NewStringElement(string(c.text))
            })
            / ElementPlaceHolder
            / AttributeSubstitution
            / ("{" { 
                return types.NewStringElement(string(c.text))
            }))+ {
                return types.Reduce(elements, strings.TrimSpace), nil
            }
        )
    "]]" {
        return types.NewIDAttribute(id)
    }

// shorthand syntax for titles. Eg: `.a title`
ShortHandTitle <- `.` title:(
    ![. ] // may not start with a dot or a space, to avoid confusion with list items or literal block delimiters
    elements:(
        ([^\r\n\uFFFD{]+ {
            return types.NewStringElement(string(c.text))
        })
        / ElementPlaceHolder
        / AttributeSubstitution
        / ("{" { 
            return types.NewStringElement(string(c.text))
        }))+ {
            return types.Reduce(elements, strings.TrimSpace), nil
        }
    ) {
        return types.NewTitleAttribute(title)
    }

// LongHandAttributes. Eg: `[positional1,positional2,...,named1,named2,...]
// positional attributes are optional, and `positional1` can be combined with options and roles ("extras")
LongHandAttributes <-
    "[" !"[" // prevent processing nested attributes at this point (parser will need to move forward by 1 char first)
    // !Space // no space allowed on the first character
    firstPositionalAttributes:(FirstPositionalAttributes)?
    otherAttributes:(PositionalAttribute / NamedAttribute)*
    "]" {
        attributes:=[]interface{}{}
        if firstPositionalAttributes != nil {
            attributes=append(attributes, firstPositionalAttributes.([]interface{})...)
        }
        if len(otherAttributes.([]interface{})) > 0 {
            attributes=append(attributes, otherAttributes.([]interface{})...)
        }
        return types.NewAttributes(attributes...)
    }

// First positional attributes may be an ID or a style, with extra roles and options.
// Or sometimes, it's just 1 or more roles or options...
FirstPositionalAttributes <- 
    main:(
        ShortHandAttribute
    )?
    extras:( 
        ShortHandIDAttribute 
        / ShortHandOptionAttribute
        / ShortHandDotRoleAttribute
    )* ("," Space*)? 
    &{
        // make sure there was a match
        return main != nil || len(extras.([]interface{})) > 0, nil
    }
    {
        attrs:=[]interface{}{}
        if main != nil {
            attrs = append(attrs, main)
        }
        if len(extras.([]interface{})) > 0 {
            attrs = append(attrs, extras.([]interface{})...)
        }
        return attrs, nil
    }

// an `id` must be prefixed with a `#` 
ShortHandIDAttribute <- "#" id:(ShortHandAttributeValue) {
        return types.NewIDAttribute(id)
    }

ShortHandAttribute <- value:(ShortHandAttributeValue) {
        return types.NewPositionalAttribute(value)
    }

// a `role` must be prefixed with a `.` 
ShortHandDotRoleAttribute <- "." role:(ShortHandAttributeValue) {
        return types.NewRoleAttribute(role)
    }

// an `option` must be prefixed with a `%` 
ShortHandOptionAttribute <- "%" option:(ShortHandAttributeValue) {
        return types.NewOptionAttribute(option)
    }

// Shorthand Attribute Value. 
ShortHandAttributeValue <- 
    SingleQuotedAttributeValue 
    / DoubleQuotedAttributeValue 
    / elements:(
    // unquoted shorthand value may include placeholders and substitutions but NOT comma, space, equal sign and dots
    // also, cannot be followed by an `=` sign
    ([^,=.%# \r\n\uFFFD{\]]+ {
        return types.NewStringElement(string(c.text))
    }) / 
    ElementPlaceHolder /
    Quote /
    AttributeSubstitution /
    ("{" { 
        return types.NewStringElement(string(c.text))
    }))+ &[^=] {
        return types.Reduce(elements, strings.TrimSpace), nil
    }

PositionalAttribute <- (
    value:(AttributeValue) (("," Space*)? / &"]") { // TODO: see if we can just use `((",")? / &"]")` instead (ie, no need to check for Space*)
    	return types.NewPositionalAttribute(value)
    }) 
    / 
    // empty/edge-case values. Eg: `[ ]`, `[, a, b]`, `[a, ,b]`, etc.
    (value:(Space* (("," Space*) / &"]"))
    &{
        // here we can't rely on `c.text` if the content is empty 
        // (in such a case, `c.text` contains the char sequence of the previous 
        // rule that matched)
        return !types.AllNilEntries(value.([]interface{})), nil
    }
    { 
        return types.NewPositionalAttribute(nil)
    })

NamedAttribute <- key:(NamedAttributeKey) "=" Space* value:(AttributeValue) ("," Space*)? { // TODO: include `,` or expect `]`
        return types.NewNamedAttribute(key.(string), value)
    }

// The spec says attributes have be alphanumeric but does not consider foreign letters.  We are more generous.
NamedAttributeKey <- !Space [^\r\n=,\]]+ Space* {
        return strings.TrimSpace(string(c.text)), nil
    }

AttributeValue <- 
    value:(
        SingleQuotedAttributeValue 
        / DoubleQuotedAttributeValue 
        / UnquotedAttributeValue
    ) 
    &(!(Space* "=")) {
        return value, nil
    }

SingleQuotedAttributeValue <- 
    "'" 
    elements:(
        // TODO: exclude quote markers from following rule to speed up parsing?
        Quote
        / ([^\r\n\uFFFD\\{&<>']+ { // = and , signs are allowed within ' quotes 
            return types.NewStringElement(string(c.text))
        })
        / AttributeSubstitution
        / SpecialCharacter
        / ElementPlaceHolder
        / (`\'` { 
            return types.NewStringElement(`'`) // escaped quote
        }
        / `{` / `\` { 
            return types.NewStringElement(string(c.text)) 
        })
    )+ 
    "'" {
        return types.Reduce(elements), nil
    }

DoubleQuotedAttributeValue <- 
    "\"" 
    elements:(
        Quote
        / ([^\r\n\uFFFD&<>"\\{]+ { // = and , signs are allowed within " quotes
            return types.NewStringElement(string(c.text))
        }) 
        / AttributeSubstitution
        / SpecialCharacter
        / ElementPlaceHolder
        / (`\"` { 
            return types.NewStringElement(`"`) // escaped quote
        }
        / `{` / `\` { 
            return types.NewStringElement(string(c.text)) 
        })
    )+ 
    "\"" {
        return types.Reduce(elements), nil
    }

// Unquoted Attribute Value, may include spaces but not on the first position
UnquotedAttributeValue <- 
    !Space
    elements:(
        !"]" // Quick escape
        element:(
            Quote
            / ([^,=\r\n\uFFFD&<>{\] ]+ {
                return types.NewStringElement(string(c.text))
            }) 
            / Space
            / AttributeSubstitution
            / SpecialCharacter
            / ElementPlaceHolder
            / ("{" { 
                return types.NewStringElement(string(c.text))
            })
        ) {
            return element, nil
        }
    )+ 
    &{
        // post-parsing condition to verify that the value is not an empty string
        return types.Reduce(elements, strings.TrimSpace) != "", nil
    }
    {
        return types.Reduce(elements, strings.TrimSpace), nil
    }

// ------------------------------------------
// Attribute Substitution
// ------------------------------------------
AttributeSubstitution <-
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(Attributes)
    }
    element:(CounterSubstitution / AttributeValueSubstitution) {
        if err := c.hasAttributeSubstitutions(); err != nil {
            return nil, err
        }
        return element, nil
    }

AttributeValueSubstitution <- "{" name:AttributeName "}" { 
    return types.NewAttributeSubstitution(name.(string))
}

// TODO: simplify the 'start' optional attribute
CounterSubstitution <- CounterSubstitution1 / CounterSubstitution2  // / CounterSubstitutionAlpha / CounterSubstitutionAlpha2 / CounterSubstitutionStart / CounterSubstitutionStart2

CounterSubstitution1 <- "{counter:" name:AttributeName start:(CounterStart)? "}" {
    return types.NewCounterSubstitution(name.(string), false, start)
}

CounterSubstitution2 <- "{counter2:" name:AttributeName start:(CounterStart)? "}" {
    return types.NewCounterSubstitution(name.(string), true, nil)
}

CounterStart <- ":" start:([A-Za-z] {
        return string(c.text), nil
    } / [0-9]+ { 
        return strconv.Atoi(string(c.text)) 
    }) {
        return start, nil
    }

// ------------------------------------------
// BlankLine
// ------------------------------------------
BlankLine <- Space* EOF {
        return types.NewBlankLine()
    }

// -------------------------------------------------------------------------------------
// Comments
// -------------------------------------------------------------------------------------

CommentBlockStartDelimiter <- "////" Space* EOL

CommentBlockEndDelimiter <- ("////" Space* EOL) / EOF

// CommentBlock <- CommentBlockStartDelimiter content:(CommentBlockRawContent)  CommentBlockEndDelimiter {
//         return types.NewCommentBlock(content.([]interface{}), nil)
//     }

// CommentBlockRawContent <- (!CommentBlockEndDelimiter line:(RawLine) { 
//         return line, nil
//     })*


// RawLine <- !EOF content:([^\r\n]* { // line MAY have content
//         return string(c.text), nil 
//     }) EOL { 
//         return types.NewRawLine(content.(string))
//     }

CommentBlockContent <- 
    // check if enabled for the current context
    // &{
    //     return c.isCommentBlockContentEnabled(types.Comment)
    // }
    content:(RawLine) {
        return content, nil
    }

RawLine <- content:(.)* EOF {
    return types.NewRawLine(string(c.text))
}

SingleLineComment <- !CommentBlockDelimiter Space* "//" content:(SingleLineCommentContent) EOL {
        return types.NewSingleLineComment(content.(string))
    }

SingleLineCommentContent <- [^\r\n]* {
        return string(c.text), nil
    }

// ------------------------------------------
// Cross References
// ------------------------------------------
CrossReference <- InternalCrossReference / ExternalCrossReference 

InternalCrossReference <- "<<" id:(Id) Space* "," label:(CrossReferenceLabel) ">>" {
        return types.NewInternalCrossReference(id, label)
    } / "<<" id:(Id) ">>" {
        return types.NewInternalCrossReference(id, nil)
    } 

ExternalCrossReference <- "xref:" url:(FileLocation) inlineAttributes:(InlineAttributes) {
        return types.NewExternalCrossReference(url.(*types.Location), inlineAttributes.(types.Attributes))
    }

CrossReferenceLabel <- (
    ([\pL0-9][^\r\n{<>]+ { // `{`, `>` and `>` characters are not allowed as they are used for attribute substitutions and cross-references 
        return types.NewStringElement(string(c.text))
    })
    / AttributeSubstitution
    / ("{" { 
        return types.NewStringElement(string(c.text))
    })
    )+


// -------------------------------------------------------------------------------------
// Delimited Blocks
// -------------------------------------------------------------------------------------
BlockDelimiter <- !(Alphanum) // quick escape
    delimiter:(LiteralBlockDelimiter //TODO: use "start" delimiters
    / FencedBlockDelimiter 
    / ListingBlockDelimiter 
    / ExampleBlockDelimiter 
    / CommentBlockDelimiter 
    / QuoteBlockDelimiter
    / SidebarBlockDelimiter
    / PassthroughBlockDelimiter) {
        return delimiter, nil
    }

LiteralBlockDelimiter <- "...." Space* EOF {
    return types.NewBlockDelimiter(types.Literal)
}

FencedBlockDelimiter <- "```" Space* EOF {
    return types.NewBlockDelimiter(types.Fenced)
}

ListingBlockDelimiter <- "----" Space* {
    return types.NewBlockDelimiter(types.Listing)
}

SourceBlockDelimiter <- ListingBlockDelimiter

ExampleBlockDelimiter <- "====" Space* EOF {
    return types.NewBlockDelimiter(types.Example)
}

CommentBlockDelimiter <- "////" Space* EOF {
    return types.NewBlockDelimiter(types.Comment)
}

QuoteBlockDelimiter <- "____" Space* EOF {
    return types.NewBlockDelimiter(types.Quote)
}

SidebarBlockDelimiter <- "****" Space* EOF {
    return types.NewBlockDelimiter(types.Sidebar)
}

PassthroughBlockDelimiter <- "++++" Space* EOF {
    return types.NewBlockDelimiter(types.Sidebar)
}

// ------------------------------------------
// Document Body Fragment
// ------------------------------------------

// // default document fragments
// DocumentBodyFragment <- !EOF
//     line:(
//         RawSection
//         / BlankLine
//         / FileInclusion
//         / BlockAttributes
//         / AttributeDeclaration
//         / AttributeSubstitution
//         / BlockDelimiter
//         / CalloutListElement
//         / InlineElements
//     ) {
//         return line, nil
//     }

// // Document fragments for delimited block and paragraphs with verbatim content
// FencedBlockFragments <- (!FencedBlockDelimiter VerbatimDocumentFragment)* 

// ListingBlockFragments <- (!ListingBlockDelimiter VerbatimDocumentFragment)* 

// LiteralBlockFragments <- (!LiteralBlockDelimiter VerbatimDocumentFragment)* 

// LiteralParagraphFragments <- (!BlankLine VerbatimDocumentFragment)* 

// SourceBlockFragments <- (!SourceBlockDelimiter VerbatimDocumentFragment)* 

// ------------------------------------------
// Document Header and Metadata
// ------------------------------------------

// DocumentHead <- 
//     frontmatter:(FrontMatter)?
//     header:(DocumentHeader?) 
//     fragments:(DocumentFragment)* EOF {
//         return types.NewDocumentFragments(frontmatter, header, fragments.([]interface{}))
//     }

// DocumentHeader <- 
//     // check if enabled with the current substitution context
//     &{
//         ctx, err := c.substitutionContext()
//         if err != nil {
//             return false, err
//         }
//         return ctx.isSectionRuleEnabled(), nil
//     }
//     fragments:(
//         ("=" Space+ title:(SectionTitleElements) id:(InlineElementID*) EOL {
//             return types.NewSection(0, title.(types.InlineElements), id.([]interface{})) 
//         })
//         (SingleLineComment / CommentBlock)*
//         DocumentAuthors?
//         (SingleLineComment / CommentBlock)*
//         DocumentRevision? 
//     ) {
//         return types.NewDocumentHeader(fragments.([]interface{}))
//     }

DocumentTitle <- 
        "=" Space+ title:(SectionTitleElements) id:(InlineElementID*) EOL {
            return types.NewSection(0, title.(types.InlineElements), id.([]interface{})) 
        }
        
DocumentAuthorsMetadata <- 
        SingleLineComment
        / CommentBlockDelimiter
        / CommentBlockContent
        / DocumentAuthors

DocumentRevisionMetadata <- 
        SingleLineComment
        / CommentBlockDelimiter
        / CommentBlockContent
        / DocumentRevision

DocumentAuthors <- DocumentAuthorsInlineForm / DocumentAuthorsAttributeForm

DocumentAuthorsInlineForm <- Space* !":" authors:(DocumentAuthor+) EOL {
    return types.NewDocumentAuthors(authors.([]interface{}))
}

DocumentAuthorsAttributeForm <- Space* ":author:" author:(DocumentAuthor) EOL {
    return []types.DocumentAuthor{author.(types.DocumentAuthor)}, nil
}

DocumentAuthor <- Space* fullname:(DocumentAuthorName) email:(DocumentAuthorEmail)? Space* ";"? Space* {
    return types.NewDocumentAuthor(fullname, email)
}

// "<" marks the beginning of the author email, and ";" is the authors separator
DocumentAuthorName <- [^<;\r\n]+ {
    return string(c.text), nil
}

DocumentAuthorEmail <- "<" email:(([^>\r\n]+) {
    return string(c.text), nil
}) ">" {
    return email, nil
}

// see http://asciidoctor.org/docs/user-manual/#revision-number-date-and-remark
// Eg: "v1.0, October 2, 2013: First incarnation"
DocumentRevision <- Space* !":" revision:(
        (revnumber:(DocumentRevisionNumber) ","? revdate:(DocumentRevisionDate)? ":"? revremark:(DocumentRevisionRemark)? {
            return types.NewDocumentRevision(revnumber, revdate, revremark)
        }) / (revdate:(DocumentRevisionDate) ":"? revremark:(DocumentRevisionRemark)? {
            return types.NewDocumentRevision(nil, revdate, revremark)
        })) EOL {
    return revision, nil
}

// DocumentRevisionNumber MUST start with a `v` or MAY start with a `v` but MUST end with a `,`
DocumentRevisionNumber <- "v"i Digit  [^:,\r\n]+ {
    return string(c.text), nil
} / "v"i? Digit  [^:,\r\n]+ Space* &"," {
    return string(c.text), nil
}

DocumentRevisionDate <- [^:\r\n]+ {
    return string(c.text), nil
}

DocumentRevisionRemark <- [^\r\r\n]+ {
    return string(c.text), nil
}

// ------------------------------------------
// ElementPlaceHolder (DEPRECATED?)
// ------------------------------------------
ElementPlaceHolderDelimiter <- "\uFFFD"
ElementPlaceHolder <- ElementPlaceHolderDelimiter ref:([0-9]+ { return string(c.text), nil }) ElementPlaceHolderDelimiter {
    return types.NewElementPlaceHolder(ref.(string))
}

// ----------------------------------------------------------------------------
// Explicit line breaks
// ----------------------------------------------------------------------------
LineBreak <- Space "+" Space* &EOL {
        return types.NewLineBreak()    
    }

// ------------------------------------------
// File inclusions
// ------------------------------------------
FileInclusion <- 
    incl:(
        "include::" 
        path:(FileLocation) 
        inlineAttributes:(InlineAttributes) { 
            return types.NewFileInclusion(path.(*types.Location), inlineAttributes.(types.Attributes), string(c.text))
        }
    ) 
    Space* EOL {
        return incl.(types.FileInclusion), nil
    }

FileIncludeAttributes <- LongHandAttributes

// extra entrypoint
LineRanges <- value:(MultipleLineRanges 
    / MultiLineRange 
    / SingleLineRange 
    ) EOF { // must make sure that the whole content is parsed
        return value, nil
    }

MultipleLineRanges <- first:(MultiLineRange / SingleLineRange) 
    others:(
        ("," / ";") // at this point, we already got rid of the surrounding quotes, so we can accept both `,` and `;`
        other:(MultiLineRange / SingleLineRange) {
            return other, nil
    })+ {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

MultiLineRange <- start:(Number) ".." end:(Number) { // eg: lines=12..14
        return types.NewLineRange(start.(int), end.(int))
    } 

SingleLineRange <- singleline:(Number) { // eg: lines=12
        return types.NewLineRange(singleline.(int), singleline.(int))
    }

// extra entrypoint
TagRanges <- value:(MultipleTagRanges) EOF { // must make sure that the whole content is parsed
        return value, nil
    }

MultipleTagRanges <- first:(TagRange)
    others:(
        ("," / ";") // at this point, we already got rid of the surrounding quotes, so we can accept both `,` and `;`
        other:(TagRange) {
            return other, nil
    })* {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

TagRange <- tag:(Alphanums / TagWildcard) {
        return types.NewTagRange(tag.(string), true)
    } / "!" tag:(Alphanums / TagWildcard) {
        return types.NewTagRange(tag.(string), false)
    }

TagWildcard <- stars:(("*")+ {
        return string(c.text), nil
    })
    &{  
        // use a predicate to make sure that only `*` and `**` are allowed
        return len(stars.(string)) <= 2, nil 
    } {
        return stars, nil
    }

IncludedFileLine <- content:(IncludedFileStartTag / IncludedFileEndTag / . {return string(c.text), nil})* EOL {
        return types.NewIncludedFileLine(content.([]interface{}))
    }

IncludedFileStartTag <- "tag::" tag:(Alphanums {return string(c.text), nil}) "[]" {
        return types.NewIncludedFileStartTag(tag.(string))
    }

IncludedFileEndTag <- "end::" tag:(Alphanums {return string(c.text), nil}) "[]" {
        return types.NewIncludedFileEndTag(tag.(string))
    }

// ------------------------------------------
// Front Matter
// ------------------------------------------
// FrontMatter <- YamlFrontMatter 

// YamlFrontMatter <- YamlFrontMatterDelimiter content:(YamlFrontMatterContent)? YamlFrontMatterDelimiter {
//     return types.NewYamlFrontMatter(content.(string))
// }

// YamlFrontMatterDelimiter  <- "---" Space* EOL

// YamlFrontMatterContent <- ((!YamlFrontMatterDelimiter .)+)* {
    //     return string(c.text), nil
// }

FrontMatterFragment <- FrontMatterDelimiter / BlankLine / FrontMatterLine

FrontMatterDelimiter  <- "---" Space* EOF {
    return types.NewBlockDelimiter(types.FrontMatter)
}

FrontMatterLine <- (.)* {
    return types.NewStringElement(string(c.text))
}

// ------------------------------------------
// Inline Elements
// ------------------------------------------
InlineElements <- 
    elements:(comment:(SingleLineComment) {
        return types.NewInlineElements([]interface{}{comment})
    } / elements:(InlineElement)+ EOL { 
        return types.NewInlineElements(elements.([]interface{}))
    }) {
        return elements, nil
    }


// TODO: group as below and enable based on substitution context.
// Also, add Callouts

// "specialcharacters",
// "quotes",
// "attributes",
// "replacements",
// "macros",
// "post_replacements",
InlineElement <-  
    element:(InlineWord // more permissive than the 'Word' rule
        / LineBreak // must be before spaces
        / Space+ 
        / !EOL (
            SpecialCharacter
            / Quote
            / AttributeSubstitution 
            / Replacement
            / InlineMacro
            / PostReplacement
            / ElementPlaceHolder // TODO: needed?
            // if anything above did not match...
            / AnyChar)) {
    return element, nil
}
// InlineElement <-  
//     element:(InlineWord // more permissive than the 'Word' rule
//         / LineBreak // must be before spaces
//         / Space+ 
//         / !EOL (
//             QuotedString
//             / QuotedText
//             / InlineIcon
//             / InlineImage 
//             / Link 
//             / InlinePassthrough // must be before the SpecialCharacter rule (because of `+`)
//             / InlineFootnote 
//             / CrossReference // must appear before SpecialCharacter
//             / Callout
//             / SpecialCharacter
//             / Symbol
//             / InlineUserMacro 
//             / AttributeSubstitution 
//             / InlineElementID
//             / ConcealedIndexTerm
//             / IndexTerm
//             / ElementPlaceHolder
//             / AnyChar)) {
//     return element, nil
// }

// ------------------------------------------
// InlineElement ID
// ------------------------------------------
InlineElementID <- "[[" id:(Id) "]]" Space* { // no EOL here since there can be multiple InlineElementID on the same line
    return types.NewInlineIDAttribute(id.(string))
}

// ------------------------------------------
// Index Terms
// ------------------------------------------
IndexTerm <- "((" term:(IndexTermContent) "))" {
       return types.NewIndexTerm(term.(types.InlineElements))
}

IndexTermContent <- elements:(Word / QuotedString / QuotedText / Space / SpecialCharacter / ElementPlaceHolder / (!"))" .) {
    return string(c.text), nil
})+ {
    return types.NewInlineElements(elements.([]interface{}))
}

ConcealedIndexTerm <- "(((" term1:(ConcealedIndexTermContent) 
    term2:(Space* "," Space* content:(ConcealedIndexTermContent) { return content, nil })? 
    term3:(Space* "," Space* content:(ConcealedIndexTermContent) { return content, nil })? 
    ")))" {
        return types.NewConcealedIndexTerm(term1, term2, term3)
    }

ConcealedIndexTermContent <- (Alphanum / Space)+ {
    return string(c.text), nil
}

// ------------------------------------------
// Images
// ------------------------------------------
ImageBlock <- 
    // &{
    //     // AttrPositional1 must not be set
    //     return types.HasNotAttribute(c.globalStore.getAttributes(), types.AttrPositional1), nil
    // }
    #{
        // for images, we always enable the 'normal' substitutions
        return c.setCurrentSubstitution("normal")
    }
    "image::" path:(Location) inlineAttributes:(InlineAttributes) Space* {
        c.unsetCurrentSubstitution()
        // 'imagesdir' attribute is added after applying the attribute substitutions on the image location
        return types.NewImageBlock(path.(*types.Location), inlineAttributes.(types.Attributes), c.globalStore.getAttributes())
    }

InlineImage <- "image:" !":" path:(Location) inlineAttributes:(InlineAttributes) {
        return types.NewInlineImage(path.(*types.Location), inlineAttributes.(types.Attributes), c.globalStore["imagesdir"])
    }

// ------------------------------------------------------------------------------------
// Inline Icons
// ------------------------------------------------------------------------------------
InlineIcon <- "icon:" icon:([\pL0-9_-]+ { return string(c.text), nil }) attributes:(InlineAttributes) {
        return types.NewIcon(icon.(string), attributes)
    }

// ------------------------------------------------------------------------------------
// Inline Foot Notes
// ------------------------------------------------------------------------------------
InlineFootnote <- "footnote:[" content:(FootnoteContent) "]" {
        return types.NewFootnote("", content.([]interface{}))
    } / "footnote:" ref:(FootnoteRef) "[" content:(FootnoteContent)? "]" {
        return types.NewFootnote(ref.(string), content)
    }

FootnoteRef <- Alphanums

FootnoteContent <- elements:(!"]" InlineElement)+  { // footnote content may span multiple lines
        return types.NewInlineElements(elements.([]interface{}))
    }

// ------------------------------------------
// Passthrough
// ------------------------------------------

SinglePlusPassthroughPrefix <- "+"

SinglePlusPassthrough <- SinglePlusPassthroughPrefix content:(SinglePlusPassthroughContent) SinglePlusPassthroughPrefix !Alphanum {
        return types.NewInlinePassthrough(types.SinglePlusPassthrough, []interface{}{content})
    }

SinglePlusPassthroughContent <- ((!SinglePlusPassthroughPrefix !Space !Newline .) (!(Space+ SinglePlusPassthroughPrefix) !SinglePlusPassthroughPrefix !Newline .)* { // no space in the first or last position of the content, but allowed elsewhere
        return types.NewStringElement(string(c.text))
    }) / ((!Space !Newline !SinglePlusPassthroughPrefix .)  { // a single character
        return types.NewStringElement(string(c.text))
    })

TriplePlusPassthroughPrefix <- "+++"

TriplePlusPassthrough <- TriplePlusPassthroughPrefix content:(TriplePlusPassthroughContent) TriplePlusPassthroughPrefix !Alphanum {
        return types.NewInlinePassthrough(types.TriplePlusPassthrough, []interface{}{content})
    }

TriplePlusPassthroughContent <- ((!TriplePlusPassthroughPrefix .)* { // spaces and newlines are also allowed in the first or last position of the content and elsewhere too
        return types.NewStringElement(string(c.text))
    }) / ((!Space !Newline !TriplePlusPassthroughPrefix .)?  { // a single character
        return types.NewStringElement(string(c.text))
    })

PassthroughMacro <- "pass:[" content:(PassthroughMacroCharacter)* "]" {
        return types.NewInlinePassthrough(types.PassthroughMacro, []interface{}{content})
    } / "pass:q[" content:(QuotedText / PassthroughMacroCharacter)* "]" {
        return types.NewInlinePassthrough(types.PassthroughMacro, content.([]interface{}))
    }

PassthroughMacroCharacter <- [^\]] {
        return types.NewStringElement(string(c.text))
    }

// ------------------------------------------
// Links
// ------------------------------------------
Link <- RelativeLink / ExternalLink

// url preceeding with `link:` MUST be followed by square brackets
RelativeLink <- "link:" url:(Location) inlineAttributes:(InlineAttributes) {
        return types.NewInlineLink(url.(*types.Location), inlineAttributes.(types.Attributes))
    }

ExternalLink <- url:(LocationWithScheme) inlineAttributes:(InlineAttributes)? {
        return types.NewInlineLink(url.(*types.Location), inlineAttributes)
    }


// ----------------------------------------------------------------------------
// List elements
// ----------------------------------------------------------------------------
ListElement <-
        OrderedListElement 
        / UnorderedListElement
        / LabeledListItem // handled at the RawLine level (with search for `:: `)
        / CalloutListElement


// Ordered List Elements
OrderedListElement <- prefix:(OrderedListElementPrefix) content:(OrderedListElementContent) {
    return types.NewOrderedListElement(prefix.(types.OrderedListElementPrefix), content.([]interface{}))
}

OrderedListElementPrefix <- 
    Space* prefix:(
        // implicit numbering: "." to "....."
        depth:((".")+ {   
            // `.` is 1, etc.
            return (len(c.text)), nil 
        }) 
        &{  
            // use a predicate to make sure that only `.` to `.....` are allowed
            return depth.(int) <= 5, nil 
        } 
        {
            switch depth.(int){
            case 1:
                return types.NewOrderedListElementPrefix(types.Arabic)
            case 2:
                return types.NewOrderedListElementPrefix(types.LowerAlpha)
            case 3:
                return types.NewOrderedListElementPrefix(types.LowerRoman)
            case 4:
                return types.NewOrderedListElementPrefix(types.UpperAlpha)
            default:
                return types.NewOrderedListElementPrefix(types.UpperRoman)
            }
        }
        // explicit numbering
        / ([0-9])+ "." {  // numbering style: "1."
            return types.NewOrderedListElementPrefix(types.Arabic)
        } / ([a-z]) "." { // numbering style: "a."
            return types.NewOrderedListElementPrefix(types.LowerAlpha)
        } / ([A-Z]) "." { // numbering style: "A."
            return types.NewOrderedListElementPrefix(types.UpperAlpha)
        } / ([ivxdlcm])+ ")" { // numbering style: "i)"
            return types.NewOrderedListElementPrefix(types.LowerRoman)
        } / ([IVXDLCM])+ ")" { // numbering style: "I)"
            return types.NewOrderedListElementPrefix(types.UpperRoman)
        }) Space+ {
    return prefix, nil
}

OrderedListElementContent <- [^\r\n]* { 
    return []interface{}{
        &types.Paragraph{
            Elements: []interface{}{
                types.RawLine(string(c.text)),
            },
        },
    }, nil 
}

// Unordered List Elements
UnorderedListElement <- 
    prefix:(UnorderedListElementPrefix) 
    checkstyle:(UnorderedListElementCheckStyle)? 
    content:(UnorderedListElementContent) {
        return types.NewUnorderedListElement(prefix.(types.UnorderedListElementPrefix), checkstyle, content.([]interface{}))
    }

UnorderedListElementPrefix <- 
    Space* prefix:((
        // implicit numbering: "*" to "*****" 
        depth:(("*")+ {   
            // `*` is 1, etc.
            return (len(c.text)), nil 
        }) 
        &{  
            // use a predicate to make sure that only `*` to `*****` are allowed
            return depth.(int) <= 5, nil 
        } 
        {
            switch depth.(int){
            case 1:
                return types.NewUnorderedListElementPrefix(types.OneAsterisk)
            case 2:
                return types.NewUnorderedListElementPrefix(types.TwoAsterisks)
            case 3:
                return types.NewUnorderedListElementPrefix(types.ThreeAsterisks)
            case 4:
                return types.NewUnorderedListElementPrefix(types.FourAsterisks)
            default:
                return types.NewUnorderedListElementPrefix(types.FiveAsterisks)
            }
        }) / depth:(("-") {
            return types.NewUnorderedListElementPrefix(types.Dash)
        })) Space+ {
    return prefix, nil
} 

UnorderedListElementCheckStyle <- &"[" style:(
      "[ ]" { return types.Unchecked, nil } 
    / "[*]" { return types.Checked, nil } 
    / "[x]" { return types.Checked, nil }
    ) Space+ {
        return style, nil
    }

// UnorderedListElementContent <- elements:(ListParagraph+) { // Another list or a literal paragraph immediately following a list item will be implicitly included in the list item
//     return types.NewListItemContent(elements.([]interface{}))
// } 

UnorderedListElementContent <- [^\r\n]* { 
    return []interface{}{
        &types.Paragraph{
            Elements: []interface{}{
                types.RawLine(string(c.text)),
            },
        },
    }, nil 
}

LabeledListItem <- term:(LabeledListItemTerm) separator:(LabeledListItemSeparator) description:(LabeledListItemDescription)? {
    return types.NewLabeledListElement(len(separator.(string)) - 1, term.(string), description)
}

LabeledListItemTerm <- (!LabeledListItemSeparator .)* {
    return string(c.text), nil
}

LabeledListItemSeparator <- 
    separator:((":")+ {   
        return string(c.text), nil
    }) 
    &{  
        // use a predicate to make sure that only `::` to `::::` are allowed
        return len(separator.(string)) >= 2 && len(separator.(string)) <= 4, nil 
    } 
    ((Space / Newline)+ / EOL) {
    return separator, nil
}

LabeledListItemDescription <- [^\r\n]+ { 
    return string(c.text), nil
}

Callout <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(Callouts)
    }
    "<" ref:([0-9]+ { return strconv.Atoi(string(c.text)) }) ">" Space* &(EOL / Callout) {
        return types.NewCallout(ref.(int))
    }

CalloutListElement <- ref:(CalloutListElementPrefix) description:(CalloutListElementContent) {
        return types.NewCalloutListElement(ref.(int), description.([]interface{}))
    }

CalloutListElementPrefix <- "<" ref:([0-9]+ { return strconv.Atoi(string(c.text)) }) ">" Space+ {
        return ref, nil
    }

CalloutListElementContent <- [^\r\n]* { 
    return []interface{}{
        &types.Paragraph{
            Elements: []interface{}{
                types.RawLine(string(c.text)),
            },
        },
    }, nil 
}

ListElementContinuation <- "+" Space* {
    return types.NewListElementContinuation()    
}

// ----------------------------------------------------------------------------
// Quoted Texts (bold, italic, monospace, marked, superscript and subscript)
// ----------------------------------------------------------------------------
QuotedText <- 
    (
        attributes:(LongHandAttributes)? // TODO: do not check for attributes on quoted text if we're already parsing an attribute value?
        text:(UnconstrainedQuotedText / ConstrainedQuotedText) {
            return text.(*types.QuotedText).WithAttributes(attributes)
        }
    ) 
    / EscapedQuotedText

ConstrainedQuotedTextMarker <- "*" !"*" / "_" !"_" / "#" !"#" / "`" !"`"

UnconstrainedQuotedTextPrefix <- "**" / "__" / "``" / "##" / "^" / "~"

ConstrainedQuotedText <- 
    SingleQuoteBoldText 
    / SingleQuoteItalicText
    / SingleQuoteMarkedText
    / SingleQuoteMonospaceText 
    / SubscriptText 
    / SuperscriptText 

UnconstrainedQuotedText <- 
    DoubleQuoteBoldText
    / DoubleQuoteItalicText
    / DoubleQuoteMarkedText
    / DoubleQuoteMonospaceText

EscapedQuotedText <- // TODO: use something like `&('\')` to quickly escape?
    &(`\`)
    element:(
        EscapedBoldText 
        / EscapedItalicText
        / EscapedMarkedText
        / EscapedMonospaceText 
        / EscapedSubscriptText 
        / EscapedSuperscriptText
    ) {
        return element, nil
    }


SubscriptOrSuperscriptPrefix <- "^" / "~" { // rule used within `words` to detect superscript or subscript portions, eg in math formulae.
        return string(c.text), nil
    }

OneOrMoreBackslashes <- `\`+ {
        return string(c.text), nil
    }

TwoOrMoreBackslashes <- `\\` `\`* {
        return string(c.text), nil
    }

// -----------------
// Quoted Bold Text
// -----------------
BoldText <- DoubleQuoteBoldText / SingleQuoteBoldText // double punctuation must be evaluated first

DoubleQuoteBoldText <- "**" elements:(DoubleQuoteBoldTextElements) "**" {
        return types.NewQuotedText(types.DoubleQuoteBold, elements.([]interface{}))
    } 

DoubleQuoteBoldTextElements <- DoubleQuoteBoldTextElement*  

DoubleQuoteBoldTextElement <- !("**") element:(Word
    / Space // may start and end with spaces
    / Newline !Newline
    / AttributeSubstitution
    / SpecialCharacter
    / InlineMacro
    / QuotedString
    / QuotedTextInDoubleQuoteBoldText
    / ElementPlaceHolder
    / DoubleQuoteBoldTextFallbackCharacter) {
        return element, nil
    }

QuotedTextInDoubleQuoteBoldText <- 
    attributes:(LongHandAttributes)? 
    text:(SingleQuoteBoldText
        / ItalicText
        / MarkedText
        / MonospaceText
        / SubscriptText
        / SuperscriptText) {
            return text.(*types.QuotedText).WithAttributes(attributes)
        }

DoubleQuoteBoldTextFallbackCharacter <-
    [^\r\n*] // anything except EOL and bold delimiter (fallback in case nothing else matched)
    / "**" Alphanums {  // or a bold delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

SingleQuoteBoldText <- 
    ("*" !"*") elements:(SingleQuoteBoldTextElements) "*" &(!Alphanum) { // single punctuation cannot be followed by a character (needs '**' to emphazise a portion of a word)
        return types.NewQuotedText(types.SingleQuoteBold, elements.([]interface{}))
    } / "*" elements:("*" SingleQuoteBoldTextElements) "*" { // unbalanced `**` vs `*` punctuation.
        return types.NewQuotedText(types.SingleQuoteBold, elements.([]interface{})) // include the second heading `*` as a regular StringElement in the bold content
    } 

SingleQuoteBoldTextElements <- !Space SingleQuoteBoldTextElement+

SingleQuoteBoldTextElement <- 
    Word
    / Newline !Newline
    / AttributeSubstitution
    / SpecialCharacter
    / InlineMacro
    / QuotedString
    / Space+ ('*' !'*')?
    / QuotedTextInSingleQuoteBoldText
    / ElementPlaceHolder
    / SingleQuoteBoldTextFallbackCharacter

QuotedTextInSingleQuoteBoldText <- 
    attributes:(LongHandAttributes)? 
    text:(DoubleQuoteBoldText
        / ItalicText
        / MarkedText
        / MonospaceText
        / SubscriptText
        / SuperscriptText) {
            return text.(*types.QuotedText).WithAttributes(attributes)
        }
SingleQuoteBoldTextFallbackCharacter <-
    [^\r\n*] // anything except EOL and bold delimiter (fallback in case nothing else matched)
    / "*" Alphanums {  // or a bold delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

EscapedBoldText <- 
    backslashes:(TwoOrMoreBackslashes) "**" elements:(DoubleQuoteBoldTextElements) "**" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "**", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "**" elements:(SingleQuoteBoldTextElements) "*" { // unbalanced `**` vs `*` punctuation
        result := append([]interface{}{"*"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "*", result)
    } / backslashes:(OneOrMoreBackslashes) "*" elements:(SingleQuoteBoldTextElements) "*" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "*", elements.([]interface{}))
    }

// -------------------
// Quoted Italic Text
// -------------------
ItalicText <- DoubleQuoteItalicText / SingleQuoteItalicText

DoubleQuoteItalicText <- "__" elements:(DoubleQuoteItalicTextElements) "__" { // double punctuation must be evaluated first
        return types.NewQuotedText(types.DoubleQuoteItalic, elements.([]interface{}))
    }

DoubleQuoteItalicTextElements <- DoubleQuoteItalicTextElement* 

DoubleQuoteItalicTextElement <- 
    !("__") element:(Word
    / Space // may start and end with spaces
    / Newline !Newline
    / AttributeSubstitution
    / SpecialCharacter
    / InlineMacro
    / QuotedString
    / QuotedTextInDoubleQuoteItalicText
    / ElementPlaceHolder
    / DoubleQuoteItalicTextFallbackCharacter) {
        return element, nil
    }

QuotedTextInDoubleQuoteItalicText <- 
    attributes:(LongHandAttributes)? 
    text:(SingleQuoteItalicText
        / BoldText
        / MarkedText
        / MonospaceText
        / SubscriptText
        / SuperscriptText) {
            return text.(*types.QuotedText).WithAttributes(attributes)
        }

DoubleQuoteItalicTextFallbackCharacter <-
    [^\r\n_] // anything except EOL and italic delimiter (fallback in case nothing else matched)
    / "__" Alphanums {  // or a italic delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

SingleQuoteItalicText <- 
    ("_" !"_") elements:(SingleQuoteItalicTextElements) "_" { // single punctuation cannot be followed by a character (needs '__' to emphazise a portion of a word)
        return types.NewQuotedText(types.SingleQuoteItalic, elements.([]interface{}))
    } / "_" elements:("_" SingleQuoteItalicTextElements) "_" { // unbalanced `__` vs `_` punctuation.
        return types.NewQuotedText(types.SingleQuoteItalic, elements.([]interface{})) // include the second heading `_` as a regular StringElement in the italic content
    } 

SingleQuoteItalicTextElements <- !Space elements:(SingleQuoteItalicTextElement+) {
    return elements, nil
}

SingleQuoteItalicTextElement <- 
    ItalicWord
    / Space+ ('_' !'_')?
    / Newline !Newline
    / AttributeSubstitution
    / SpecialCharacter
    / InlineMacro
    / QuotedString
    / QuotedTextInSingleQuoteItalicText
    / ElementPlaceHolder
    / SingleQuoteItalicTextFallbackCharacter

// TODO: verify and use similar rule on kinds of quote
ItalicWord <- [\pL0-9]+ &(" " / "_") {
    return types.NewStringElement(string(c.text))
}

QuotedTextInSingleQuoteItalicText <-
    attributes:(LongHandAttributes)? 
    text:(BoldText
        / DoubleQuoteItalicText
        / MarkedText
        / MonospaceText
        / SubscriptText
        / SuperscriptText) {
            return text.(*types.QuotedText).WithAttributes(attributes)
        }

SingleQuoteItalicTextFallbackCharacter <-
    [^\r\n_] // anything except EOL and italic delimiter (fallback in case nothing else matched)
    / "_" Alphanums {  // or an italic delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

EscapedItalicText <- 
    backslashes:(TwoOrMoreBackslashes) "__" elements:(DoubleQuoteItalicTextElements) "__" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "__", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "__" elements:(SingleQuoteItalicTextElements) "_" { // unbalanced `__` vs `_` punctuation
        result := append([]interface{}{"_"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "_", result)
    } / backslashes:(OneOrMoreBackslashes) "_" elements:(SingleQuoteItalicTextElements) "_" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "_", elements.([]interface{}))
} 

// ----------------------
// Quoted Monospace Text
// ----------------------
MonospaceText <- DoubleQuoteMonospaceText / SingleQuoteMonospaceText

DoubleQuoteMonospaceText <- "``" elements:(DoubleQuoteMonospaceTextElements) "``" { // double punctuation must be evaluated first
        return types.NewQuotedText(types.DoubleQuoteMonospace, elements.([]interface{}))
    }

DoubleQuoteMonospaceTextElements <- DoubleQuoteMonospaceTextElement* // may start and end with spaces

DoubleQuoteMonospaceTextElement <- 
    !("``") element:(Word
    / Space // may start and end with spaces
    / Newline !Newline
    / AttributeSubstitution
    / SpecialCharacter
    / InlineMacro
    / QuotedString
    / RawApostrophe // must be before SingleQuoteMonospaceText
    / QuotedTextInDoubleQuoteMonospaceText
    / ElementPlaceHolder
    / DoubleQuoteMonospaceTextFallbackCharacter) {
        return element, nil
    }

QuotedTextInDoubleQuoteMonospaceText <-
    attributes:(LongHandAttributes)? 
    text:(SingleQuoteMonospaceText
        / BoldText
        / ItalicText
        / MarkedText
        / SubscriptText
        / SuperscriptText) {
             return text.(*types.QuotedText).WithAttributes(attributes)
        }

DoubleQuoteMonospaceTextFallbackCharacter <-
    [^\r\n`] // anything except EOL and monospace delimiter (fallback in case nothing else matched)
    / "``" Alphanums {  // ` or a monospace delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

SingleQuoteMonospaceText <- 
    ("`" !"`") elements:(SingleQuoteMonospaceTextElements) "`" { // single punctuation cannot be followed by a character (needs "``" to emphazise a portion of a word)
        return types.NewQuotedText(types.SingleQuoteMonospace, elements.([]interface{}))
    } / "`" elements:("`" SingleQuoteMonospaceTextElements) "`" { // unbalanced "``" vs "`" punctuation.
       return types.NewQuotedText(types.SingleQuoteMonospace, elements.([]interface{})) // include the second heading "`" as a regular StringElement in the monospace content
    }

SingleQuoteMonospaceTextElements <- !Space SingleQuoteMonospaceTextElement+

SingleQuoteMonospaceTextElement <-  
    Word
    / Newline !Newline
    / AttributeSubstitution
    / SpecialCharacter
    / InlineMacro
    / QuotedString
    / Space+ ('`' !'`')?  // allow for content such as "`some `nested monospace`". Also, do not allow for double backticks after spaces.
    / QuotedTextInSingleQuoteMonospaceText
    / RawApostrophe
    / ElementPlaceHolder
    / SingleQuoteMonospaceTextFallbackCharacter

QuotedTextInSingleQuoteMonospaceText <-
    attributes:(LongHandAttributes)? 
    text:(DoubleQuoteMonospaceText
        / BoldText
        / ItalicText
        / MarkedText
        / SubscriptText
        / SuperscriptText) {
             return text.(*types.QuotedText).WithAttributes(attributes)
        }

SingleQuoteMonospaceTextFallbackCharacter <-
    ([^\r\n`] // ` anything except EOL and monospace delimiter (fallback in case nothing else matched)
    / "`" Alphanums) {  // or an monospace delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

EscapedMonospaceText <- 
    backslashes:(TwoOrMoreBackslashes) "``" elements:(DoubleQuoteMonospaceTextElements) "``" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "``", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "``" elements:(SingleQuoteMonospaceTextElements) "`" { // unbalanced "``" vs "`" punctuation
        result := append([]interface{}{"`"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "`", result)
    } / backslashes:(OneOrMoreBackslashes) "`" elements:(SingleQuoteMonospaceTextElements) "`" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "`", elements.([]interface{}))
    }

// -------------------
// Quoted Marked Text
// -------------------
MarkedText <- DoubleQuoteMarkedText / SingleQuoteMarkedText

DoubleQuoteMarkedText <- "##" elements:(DoubleQuoteMarkedTextElements) "##" { // double punctuation must be evaluated first
        return types.NewQuotedText(types.DoubleQuoteMarked, elements.([]interface{}))
    }

DoubleQuoteMarkedTextElements <- DoubleQuoteMarkedTextElement (!("##") (Space / DoubleQuoteMarkedTextElement))*  // may start and end with spaces

DoubleQuoteMarkedTextElement <- Word
    / Newline !Newline
    / AttributeSubstitution
    / SpecialCharacter
    / InlineMacro
    / QuotedString
    / NonDoubleQuoteMarkedText
    / ElementPlaceHolder
    / DoubleQuoteMarkedTextFallbackCharacter

NonDoubleQuoteMarkedText <-
    attributes:(LongHandAttributes)? 
    text:(BoldText
        / ItalicText
        / MonospaceText
        / SingleQuoteMarkedText
        / SubscriptText
        / SuperscriptText) {
             return text.(*types.QuotedText).WithAttributes(attributes)
        }

DoubleQuoteMarkedTextFallbackCharacter <-
    [^\r\n#] // anything except EOL and marked delimiter (fallback in case nothing else matched)
    / "##" Alphanums {  // or a marked delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

SingleQuoteMarkedText <- ("#" !"#") elements:(SingleQuoteMarkedTextElements) "#" { // single punctuation cannot be followed by a character (needs '##' to emphazise a portion of a word)
        return types.NewQuotedText(types.SingleQuoteMarked, elements.([]interface{}))
    } / "#" elements:("#" SingleQuoteMarkedTextElements) "#" { // unbalanced `##` vs `#` punctuation.
        return types.NewQuotedText(types.SingleQuoteMarked, elements.([]interface{})) // include the second heading `_` as a regular StringElement in the italic content
    }

SingleQuoteMarkedTextElements <- !Space SingleQuoteMarkedTextElement+

SingleQuoteMarkedTextElement <- Word
    / Newline !Newline
    / AttributeSubstitution
    / SpecialCharacter
    / InlineMacro
    / QuotedString
    / Space+ ('#' !'#')?
    / NonSingleQuoteMarkedText
    / ElementPlaceHolder
    / SingleQuoteMarkedTextFallbackCharacter

NonSingleQuoteMarkedText <-
    attributes:(LongHandAttributes)? 
    text:(DoubleQuoteMarkedText
        / BoldText
        / ItalicText
        / MonospaceText
        / SubscriptText
        / SuperscriptText) {
             return text.(*types.QuotedText).WithAttributes(attributes)
        }
SingleQuoteMarkedTextFallbackCharacter <-
    [^\r\n#] // anything except EOL and mark delimiter (fallback in case nothing else matched)
    / "#" Alphanums {  // or a mark delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

EscapedMarkedText <-
    backslashes:(TwoOrMoreBackslashes) "##" elements:(DoubleQuoteMarkedTextElements) "##" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "##", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "##" elements:(SingleQuoteMarkedTextElements) "#" { // unbalanced `##` vs `#` punctuation
        result := append([]interface{}{"#"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "#", result)
    } / backslashes:(OneOrMoreBackslashes) "#" elements:(SingleQuoteMarkedTextElements) "#" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "#", elements.([]interface{}))
    }

// ---------------------
// Quoted Subscript Text
// ---------------------
SubscriptText <- "~" element:(SubscriptTextElement) "~" { // wraps a single word
        return types.NewQuotedText(types.SingleQuoteSubscript, element)
    }

SubscriptTextElement <- QuotedText / NonSubscriptText 

NonSubscriptText <- [^\r\n ~]+ { // anything except spaces, EOL or '~'
        return c.text, nil
    }

EscapedSubscriptText <- backslashes:(OneOrMoreBackslashes) "~" element:(SubscriptTextElement) "~" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "~", element)
    } 

// -----------------------
// Quoted Superscript Text
// -----------------------
SuperscriptText <- "^" element:(SuperscriptTextElement) "^" { // wraps a single word
        return types.NewQuotedText(types.SingleQuoteSuperscript, element)
    }

SuperscriptTextElement <- QuotedText / NonSuperscriptText 

NonSuperscriptText <- [^\r\n ^]+ { // anything except spaces, EOL or '^'
        return c.text, nil
    }

EscapedSuperscriptText <- backslashes:(OneOrMoreBackslashes) "^" element:(SuperscriptTextElement) "^" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "^", element)
    } 

// ------------------------------------------------------
// Quoted Strings (between curly single or double quotes)
// ------------------------------------------------------

QuotedString <- SingleQuotedString / DoubleQuotedString

SingleQuotedString <- SingleQuoteStringStart elements:SingleQuotedStringElements SingleQuoteStringEnd {
        return types.NewQuotedString(types.SingleQuote, elements.([]interface{}))
    }

SingleQuotedStringElements <- elements:(SingleQuotedStringElement+) {
        return types.NewInlineElements(elements)
    }

SingleQuoteStringStart <- "'`" ![ \t\r\n]

SingleQuoteStringEnd <- "`'"

// We have to treat this one special, because of ambiguity with monospace markup.
SingleQuotedStringElement <- 
    element:(
        LineBreak !SingleQuoteStringEnd // must be before spaces
        / Space+ !SingleQuoteStringEnd
        / (!"`" element:(Symbol) { return element, nil}) // Exclude the explicit quote
        / QuotedTextInSingleQuotedString
        / DoubleQuotedString
        / SingleQuotedStringFallbackCharacter
    ) {
        return element, nil
    }

QuotedTextInSingleQuotedString <-
    attributes:(LongHandAttributes)? 
    text:(BoldText
        / ItalicText
        / (!"`'" element:(MonospaceText) { return element, nil})
        / SubscriptText
        / SuperscriptText
        / MarkedText) {
             return text.(*types.QuotedText).WithAttributes(attributes)
        }

SingleQuotedStringFallbackCharacter <-  [^\r\n\t `] / "`" !"'" { // '
        return types.NewStringElement(string(c.text))
    }

DoubleQuotedString <- DoubleQuoteStringStart elements:DoubleQuotedStringElements DoubleQuoteStringEnd {
        return types.NewQuotedString(types.DoubleQuote, elements.([]interface{}))
    }

DoubleQuotedStringElements <- elements:(DoubleQuotedStringElement+) {
        return types.NewInlineElements(elements)
    }

// We have to treat this one special, because of ambiguity with monospace markup.
DoubleQuotedStringElement <- element:(
    LineBreak !DoubleQuoteStringEnd // must be before spaces
    / Space+ !DoubleQuoteStringEnd
    / QuotedTextInDoubleQuotedString
    / SingleQuotedString
    / DoubleQuotedStringFallbackCharacter) {
        return element, nil
    }

QuotedTextInDoubleQuotedString <-
    attributes:(LongHandAttributes)? 
    text:(BoldText
        / ItalicText
        / (!"`\"" element:(MonospaceText) { return element, nil})
        / SubscriptText
        / SuperscriptText
        / MarkedText) {
             return text.(*types.QuotedText).WithAttributes(attributes)
        }

DoubleQuoteStringStart <- "\"`" ![ \t\r\n]

DoubleQuoteStringEnd <- "`\""

DoubleQuotedStringFallbackCharacter <-  ([^\r\n\t `] / "`" !"\"") {
        return types.NewStringElement(string(c.text))
    }


// ------------------------------------------
// Sections
// ------------------------------------------
// we need to identify section titles to properly handle file inclusions with level offsets
Section <- 
    level:(("=")+ {   
        // `=` is level 0, `==` is level 1, etc.
        return (len(c.text)-1), nil 
    })
    &{  
        // use a predicate to make sure that only `=` (level 0) to `======` (level 5) are allowed
        return level.(int) <= 5, nil 
    } 
    // #{
    //     // for section, we always enable the 'normal' substitutions
    //     return c.setCurrentSubstitution("normal")
    // }
    // Space+ title:(SectionTitleElements) id:(InlineElementID*) {
    //     c.unsetCurrentSubstitution()
    //     return types.NewSection(level.(int), title.(types.InlineElements), id.([]interface{})) 
    // }
    Space+ title:(RawSectionTitle) EOL {
        return types.NewRawSection(level.(int), title.([]interface{})) 
    }

// SectionTitleElements <- elements:(!Newline !InlineElementID SectionTitleElement)+ { // absorbs heading and trailing spaces
//         return types.NewInlineElements(elements.([]interface{}))
//     } 

// SectionTitleElement <- NormalGroup

// // we need to identify section titles to properly handle file inclusions with level offsets
// RawSection <- 
//     level:(("=")+ {   
//         // `=` is level 0, etc.
//         return (len(c.text)-1), nil 
//     })
//     &{  
//         // use a predicate to make sure that only `=` (level 0) to `======` (level 5) are allowed
//         return level.(int) <= 5, nil 
//     } 
//     Space+ title:(RawSectionTitle) EOL {
//     return types.NewRawSection(level.(int), title.(string)) 
// }

RawSectionTitle <- [^\r\n]* { 
    return []interface{}{
        types.RawLine(c.text),
    }, nil 
}

// -------------------------------------------------------------------------------------
// Substitutions
// -------------------------------------------------------------------------------------

// Substitution group for 'attributes' only
AttributesGroup <- elements:(
    InlineWord
    / InlinePassthrough
    / AttributeSubstitution
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / AnyChar)+ EOF { 
        return types.Merge(elements), nil
    }

// Substitution group element attributes
ElementAttributesGroup <- elements:(
    InlineWord
    / AttributeSubstitution
    / Quotes
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / AnyChar)+ EOF { 
        return types.Merge(elements), nil
    }

// Default substitutions for Section Titles
HeaderGroup <- elements:(
    InlineWord
    / InlinePassthrough
    / SpecialCharacter
    / Quote
    / AttributeSubstitution
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / Replacement
    / AnyChar)+ EOF { 
        return types.Merge(elements), nil
    }

// Substitution group for 'macros' only
MacrosGroup <- elements:(
    InlineWord
    / InlineMacro
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / AnyChar)+ EOF { 
        return types.Merge(elements), nil
    }

// TODO: do we really need a grammar rule? can't we just skip substitutions?
// The 'none' substitution
NoneGroup <- elements:(NormalGroupElement)+ EOF { 
        return types.Merge(elements), nil
    }

NoneGroupElement <- !EOF
    element:(
        InlineWord
        / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
        / AnyChar)+ EOF { 
            return element, nil
        }

// Default substitutions for Paragrapghs
// TODO: extract the substitutionContext once and check every rule choice here. Will also avoid setting "fake" context for BlockAttributes, SectionTitle, etc.
NormalGroup <- elements:(NormalGroupElement)+ EOF { 
        return types.Merge(elements), nil
    }

NormalGroupElement <- !EOF
    element:(
        InlineWord
        / LineBreak // must appear before space :/
        / Space
        / Newline
        / InlinePassthrough
        / SpecialCharacter
        / Quote
        / AttributeSubstitution
        / Replacement
        / InlineMacro
        / PostReplacement
        / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
        / AnyChar) {
            return element, nil
        }

// Substitution group for 'quotes' only
QuotesGroup <- elements:(
    InlineWord
    / Quote
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / AnyChar)+ EOF { 
        return types.Merge(elements), nil
    }

// Substitution group for 'replacements' only
ReplacementsGroup <- elements:(
    InlineWord
    / Replacement
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / AnyChar)+ EOF { 
        return types.Merge(elements), nil
    }

// Substitution group for 'specialcharacters' (or 'specialchars') only
SpecialCharactersGroup <- elements:(
    InlineWord
    / SpecialCharacter
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / AnyChar)+ EOF { 
        return types.Merge(elements), nil
    }

VerbatimGroup <- elements:(
    InlineWord
    / Callout // must be placed before SpecialCharacter
    / SpecialCharacter
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / AnyChar)+ EOF { 
        return types.Merge(elements), nil
    }
    
InlineMacro <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(Macros)
    }
    element:(
        InlineIcon
        / InlineImage 
        / Link 
        / InlinePassthrough 
        / InlineFootnote 
        / CrossReference 
        / InlineUserMacro 
        / InlineElementID
        / ConcealedIndexTerm
        / IndexTerm) {
            return element, nil
        }

InlinePassthrough <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(InlinePassthroughs)
    }
    element:(
        TriplePlusPassthrough / SinglePlusPassthrough / PassthroughMacro
    ) {
        return element, nil
    }

PostReplacement <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(PostReplacements)
    }
    element:(
        LineBreak
    ) {
        return element, nil
    }

Quote <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(Quotes)
    }
    element:(
        QuotedText 
        / QuotedString) {
            return element, nil
        }

Replacement <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(Replacements)
    }
    element:(
        Symbol
    ) {
        return element, nil
    }

SpecialCharacter <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(SpecialCharacters)
    }
    element:(
        // if we have a InternalCrossReference we just return a StringElement. 
        InternalCrossReference {
            return types.NewStringElement(string(c.text))
        } 
        / ("<" / ">" / "&" ) {
            return types.NewSpecialCharacter(string(c.text))
        }) {
            return element, nil
        }


// ------------------------------------------
// Symbols
// ------------------------------------------
Symbol <- Apostrophe / Copyright / Trademark / Registered / Ellipsis / ImpliedApostrophe

Apostrophe <- "`'" {
        return types.NewStringElement("\u2019")
    }

RawApostrophe <- "`'" // no conversion

Copyright <- "(C)" {
        return types.NewStringElement("\u00a9")
    }

Trademark <- "(TM)" {
        return types.NewStringElement("\u2122")
    }

Registered <- "(R)" {
        return types.NewStringElement("\u00ae")
    }

Ellipsis <- "..." {
        return types.NewStringElement("\u2026\u200b")
    }

// The implied apostrophe is used in interior words, and intended to help
// cases like "mother's day".  asciidoctor requires that it be followed by
// a letter (not a digit) but it can have a digit just before it.

ImpliedApostrophe <- Alphanum "'" &[\pL] {
        return types.NewStringElement(string(c.text[:1])+"\u2019")
    }

// -------------------------------------------------------------------------------------
// Thematic break
// -------------------------------------------------------------------------------------
ThematicBreak <- ("***" / "* * *" / "---" / "- - -" / "___" / "_ _ _") EOF {
        return types.NewThematicBreak()
    }

// ------------------------------------------
// User Macro
// ------------------------------------------
UserMacroBlock <- 
    name:(UserMacroName) 
    &{
        // skip if no macro was registered under the given name 
      return c.globalStore.hasUserMacro(name.(string)), nil  
    }
    "::" 
    value:(UserMacroValue) 
    inlineAttributes:(InlineAttributes) {
        return types.NewUserMacroBlock(name.(string), value.(string), inlineAttributes, string(c.text))
    }

InlineUserMacro <- 
    name:(UserMacroName) 
    &{
        // skip if no macro was registered under the given name 
      return c.globalStore.hasUserMacro(name.(string)), nil  
    }
    ":" 
    value:(UserMacroValue) 
    inlineAttributes:(InlineAttributes) {
        return types.NewInlineUserMacro(name.(string), value.(string), inlineAttributes, string(c.text))
    }

UserMacroName <- ([\pL0-9_-]+) {
        return string(c.text), nil
    }

UserMacroValue <- [^:[ \r\n]* {
        return string(c.text), nil
    }

// ------------------------------------------
// Base Types
// ------------------------------------------
Alphanum <- [\pL0-9]

Parenthesis <- "(" / ")" / "[" / "]" / "{" / "}" 

Alphanums <- [\pL0-9]+ {
        return string(c.text), nil
    }

Word <-
    // very straightforward content: alphanums followed by attached single quote delimiter and more characters 
    // (in this case, the quoted text delimiters are intepreted as regular characters)
    // then followed by spaces but not the "+" signs because it needs a heading space to become a LineBreak element
    [\pL0-9]+ &([\r\n ,\]] / EOF) {
        return types.NewStringElement(string(c.text))
    } / [\pL0-9]+ ([=*_`] [\pL0-9]+)+ {  // allow `
        return types.NewStringElement(string(c.text))
    }

    
InlineWord <- 
    // same as word, but:
    // - may also contain some punctuation markers
    // - must be followed by space / newline / EOF / ElementPlaceHolder delimiter (not consumed)
    content:([\pL0-9,?!;]+ {
        return types.NewStringElement(string(c.text))
    })
    &([\r\n ] / ElementPlaceHolderDelimiter / EOF) {
      return content, nil  
    } / Word

// this is a fall-back rule in case all preceeding rules failed to match the current content.
// AnyChar <- [^\r\n] { 
AnyChar <- . { 
        return types.NewStringElement(string(c.text))
    } 

FileLocation <- path:(Filename / ElementPlaceHolder)+ {
        return types.NewLocation("", path.([]interface{}))
    }

Location <- scheme:(Scheme)? path:(Filename / ElementPlaceHolder)+ {
        return types.NewLocation(scheme, path.([]interface{}))
    }

LocationWithScheme <- scheme:(Scheme) path:(Filename / ElementPlaceHolder)+ {
        return types.NewLocation(scheme, path.([]interface{}))
    }

Filename <- elements:(
    // TODO: quick escape on `]`
    ([^\r\n[\]\uFFFD{&<> ])+ { // not supported for now: EOL, space, "[", "]"
        return types.NewStringElement(string(c.text))
    }
    / AttributeSubstitution 
    / SpecialCharacter
    / "{" {
        return types.NewStringElement(string(c.text))
    })+ {
        return types.Merge(elements.([]interface{})...), nil
    }

Scheme <- "http://" / "https://" / "ftp://" / "irc://" / "mailto:"

Id <- [^[\]<>,]+ { // previously: (Alphanums / (!Newline !Space !"[" !"]" !"<<" !">>" !","  .))+
        return string(c.text), nil
    }

Digit <- [0-9] {
        return string(c.text), nil
    }

Number <- "-"? Digit+ {
        return strconv.Atoi(string(c.text))
    }

Space <- " " / "\t" {
        return string(c.text), nil
    }

Newline <- "\n" / "\r\n" / "\r" { // TODO: just use "\n" 
    return types.NewStringElement(string(c.text))
}

EOF <- !.

EOL <- EOF / Newline